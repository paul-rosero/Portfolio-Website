{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _axios = require('axios');\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _jsBase = require('js-base64');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * @file\n * @copyright  2016 Yahoo Inc.\n * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.\n *             Github.js is freely distributable.\n */\n\n\nvar log = (0, _debug2.default)('github:request');\n/**\n * The error structure returned when a network call fails\n */\n\nvar ResponseError = function (_Error) {\n  _inherits(ResponseError, _Error);\n  /**\n   * Construct a new ResponseError\n   * @param {string} message - an message to return instead of the the default error message\n   * @param {string} path - the requested path\n   * @param {Object} response - the object returned by Axios\n   */\n\n\n  function ResponseError(message, path, response) {\n    _classCallCheck(this, ResponseError);\n\n    var _this = _possibleConstructorReturn(this, (ResponseError.__proto__ || Object.getPrototypeOf(ResponseError)).call(this, message));\n\n    _this.path = path;\n    _this.request = response.config;\n    _this.response = (response || {}).response || response;\n    _this.status = response.status;\n    return _this;\n  }\n\n  return ResponseError;\n}(Error);\n/**\n * Requestable wraps the logic for making http requests to the API\n */\n\n\nvar Requestable = function () {\n  /**\n   * Either a username and password or an oauth token for Github\n   * @typedef {Object} Requestable.auth\n   * @prop {string} [username] - the Github username\n   * @prop {string} [password] - the user's password\n   * @prop {token} [token] - an OAuth token\n   */\n\n  /**\n   * Initialize the http internals.\n   * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is\n   *                                  not provided request will be made unauthenticated\n   * @param {string} [apiBase=https://api.github.com] - the base Github API URL\n   * @param {string} [AcceptHeader=v3] - the accept header for the requests\n   */\n  function Requestable(auth, apiBase, AcceptHeader) {\n    _classCallCheck(this, Requestable);\n\n    this.__apiBase = apiBase || 'https://api.github.com';\n    this.__auth = {\n      token: auth.token,\n      username: auth.username,\n      password: auth.password\n    };\n    this.__AcceptHeader = AcceptHeader || 'v3';\n\n    if (auth.token) {\n      this.__authorizationHeader = 'token ' + auth.token;\n    } else if (auth.username && auth.password) {\n      this.__authorizationHeader = 'Basic ' + _jsBase.Base64.encode(auth.username + ':' + auth.password);\n    }\n  }\n  /**\n   * Compute the URL to use to make a request.\n   * @private\n   * @param {string} path - either a URL relative to the API base or an absolute URL\n   * @return {string} - the URL to use\n   */\n\n\n  _createClass(Requestable, [{\n    key: '__getURL',\n    value: function __getURL(path) {\n      var url = path;\n\n      if (path.indexOf('//') === -1) {\n        url = this.__apiBase + path;\n      }\n\n      var newCacheBuster = 'timestamp=' + new Date().getTime();\n      return url.replace(/(timestamp=\\d+)/, newCacheBuster);\n    }\n    /**\n     * Compute the headers required for an API request.\n     * @private\n     * @param {boolean} raw - if the request should be treated as JSON or as a raw request\n     * @param {string} AcceptHeader - the accept header for the request\n     * @return {Object} - the headers to use in the request\n     */\n\n  }, {\n    key: '__getRequestHeaders',\n    value: function __getRequestHeaders(raw, AcceptHeader) {\n      var headers = {\n        'Content-Type': 'application/json;charset=UTF-8',\n        'Accept': 'application/vnd.github.' + (AcceptHeader || this.__AcceptHeader)\n      };\n\n      if (raw) {\n        headers.Accept += '.raw';\n      }\n\n      headers.Accept += '+json';\n\n      if (this.__authorizationHeader) {\n        headers.Authorization = this.__authorizationHeader;\n      }\n\n      return headers;\n    }\n    /**\n     * Sets the default options for API requests\n     * @protected\n     * @param {Object} [requestOptions={}] - the current options for the request\n     * @return {Object} - the options to pass to the request\n     */\n\n  }, {\n    key: '_getOptionsWithDefaults',\n    value: function _getOptionsWithDefaults() {\n      var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!(requestOptions.visibility || requestOptions.affiliation)) {\n        requestOptions.type = requestOptions.type || 'all';\n      }\n\n      requestOptions.sort = requestOptions.sort || 'updated';\n      requestOptions.per_page = requestOptions.per_page || '100'; // eslint-disable-line\n\n      return requestOptions;\n    }\n    /**\n     * if a `Date` is passed to this function it will be converted to an ISO string\n     * @param {*} date - the object to attempt to coerce into an ISO date string\n     * @return {string} - the ISO representation of `date` or whatever was passed in if it was not a date\n     */\n\n  }, {\n    key: '_dateToISO',\n    value: function _dateToISO(date) {\n      if (date && date instanceof Date) {\n        date = date.toISOString();\n      }\n\n      return date;\n    }\n    /**\n     * A function that receives the result of the API request.\n     * @callback Requestable.callback\n     * @param {Requestable.Error} error - the error returned by the API or `null`\n     * @param {(Object|true)} result - the data returned by the API or `true` if the API returns `204 No Content`\n     * @param {Object} request - the raw {@linkcode https://github.com/mzabriskie/axios#response-schema Response}\n     */\n\n    /**\n     * Make a request.\n     * @param {string} method - the method for the request (GET, PUT, POST, DELETE)\n     * @param {string} path - the path for the request\n     * @param {*} [data] - the data to send to the server. For HTTP methods that don't have a body the data\n     *                   will be sent as query parameters\n     * @param {Requestable.callback} [cb] - the callback for the request\n     * @param {boolean} [raw=false] - if the request should be sent as raw. If this is a falsy value then the\n     *                              request will be made as JSON\n     * @return {Promise} - the Promise for the http request\n     */\n\n  }, {\n    key: '_request',\n    value: function _request(method, path, data, cb, raw) {\n      var url = this.__getURL(path);\n\n      var AcceptHeader = (data || {}).AcceptHeader;\n\n      if (AcceptHeader) {\n        delete data.AcceptHeader;\n      }\n\n      var headers = this.__getRequestHeaders(raw, AcceptHeader);\n\n      var queryParams = {};\n      var shouldUseDataAsParams = data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && methodHasNoBody(method);\n\n      if (shouldUseDataAsParams) {\n        queryParams = data;\n        data = undefined;\n      }\n\n      var config = {\n        url: url,\n        method: method,\n        headers: headers,\n        params: queryParams,\n        data: data,\n        responseType: raw ? 'text' : 'json'\n      };\n      log(config.method + ' to ' + config.url);\n      var requestPromise = (0, _axios2.default)(config).catch(callbackErrorOrThrow(cb, path));\n\n      if (cb) {\n        requestPromise.then(function (response) {\n          if (response.data && Object.keys(response.data).length > 0) {\n            // When data has results\n            cb(null, response.data, response);\n          } else if (config.method !== 'GET' && Object.keys(response.data).length < 1) {\n            // True when successful submit a request and receive a empty object\n            cb(null, response.status < 300, response);\n          } else {\n            cb(null, response.data, response);\n          }\n        });\n      }\n\n      return requestPromise;\n    }\n    /**\n     * Make a request to an endpoint the returns 204 when true and 404 when false\n     * @param {string} path - the path to request\n     * @param {Object} data - any query parameters for the request\n     * @param {Requestable.callback} cb - the callback that will receive `true` or `false`\n     * @param {method} [method=GET] - HTTP Method to use\n     * @return {Promise} - the promise for the http request\n     */\n\n  }, {\n    key: '_request204or404',\n    value: function _request204or404(path, data, cb) {\n      var method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'GET';\n      return this._request(method, path, data).then(function success(response) {\n        if (cb) {\n          cb(null, true, response);\n        }\n\n        return true;\n      }, function failure(response) {\n        if (response.response.status === 404) {\n          if (cb) {\n            cb(null, false, response);\n          }\n\n          return false;\n        }\n\n        if (cb) {\n          cb(response);\n        }\n\n        throw response;\n      });\n    }\n    /**\n     * Make a request and fetch all the available data. Github will paginate responses so for queries\n     * that might span multiple pages this method is preferred to {@link Requestable#request}\n     * @param {string} path - the path to request\n     * @param {Object} options - the query parameters to include\n     * @param {Requestable.callback} [cb] - the function to receive the data. The returned data will always be an array.\n     * @param {Object[]} results - the partial results. This argument is intended for internal use only.\n     * @return {Promise} - a promise which will resolve when all pages have been fetched\n     * @deprecated This will be folded into {@link Requestable#_request} in the 2.0 release.\n     */\n\n  }, {\n    key: '_requestAllPages',\n    value: function _requestAllPages(path, options, cb, results) {\n      var _this2 = this;\n\n      results = results || [];\n      return this._request('GET', path, options).then(function (response) {\n        var _results;\n\n        var thisGroup = void 0;\n\n        if (response.data instanceof Array) {\n          thisGroup = response.data;\n        } else if (response.data.items instanceof Array) {\n          thisGroup = response.data.items;\n        } else {\n          var message = 'cannot figure out how to append ' + response.data + ' to the result set';\n          throw new ResponseError(message, path, response);\n        }\n\n        (_results = results).push.apply(_results, _toConsumableArray(thisGroup));\n\n        var nextUrl = getNextPage(response.headers.link);\n\n        if (nextUrl) {\n          if (!options) {\n            options = {};\n          }\n\n          options.page = parseInt(nextUrl.match(/(page=[0-9]*)/g).shift().split('=').pop());\n\n          if (!(options && typeof options.page !== 'number')) {\n            log('getting next page: ' + nextUrl);\n            return _this2._requestAllPages(nextUrl, options, cb, results);\n          }\n        }\n\n        if (cb) {\n          cb(null, results, response);\n        }\n\n        response.data = results;\n        return response;\n      }).catch(callbackErrorOrThrow(cb, path));\n    }\n  }]);\n\n  return Requestable;\n}();\n\nmodule.exports = Requestable; // ////////////////////////// //\n//  Private helper functions  //\n// ////////////////////////// //\n\nvar METHODS_WITH_NO_BODY = ['GET', 'HEAD', 'DELETE'];\n\nfunction methodHasNoBody(method) {\n  return METHODS_WITH_NO_BODY.indexOf(method) !== -1;\n}\n\nfunction getNextPage() {\n  var linksHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var links = linksHeader.split(/\\s*,\\s*/); // splits and strips the urls\n\n  return links.reduce(function (nextUrl, link) {\n    if (link.search(/rel=\"next\"/) !== -1) {\n      return (link.match(/<(.*)>/) || [])[1];\n    }\n\n    return nextUrl;\n  }, undefined);\n}\n\nfunction callbackErrorOrThrow(cb, path) {\n  return function handler(object) {\n    var error = void 0;\n\n    if (object.hasOwnProperty('config')) {\n      var _object$response = object.response,\n          status = _object$response.status,\n          statusText = _object$response.statusText,\n          _object$config = object.config,\n          method = _object$config.method,\n          url = _object$config.url;\n      var message = status + ' error making request ' + method + ' ' + url + ': \"' + statusText + '\"';\n      error = new ResponseError(message, path, object);\n      log(message + ' ' + JSON.stringify(object.data));\n    } else {\n      error = object;\n    }\n\n    if (cb) {\n      log('going to error callback');\n      cb(error);\n    } else {\n      log('throwing error');\n      throw error;\n    }\n  };\n} //# sourceMappingURL=Requestable.js.map","map":{"version":3,"sources":["Requestable.js"],"names":["log","ResponseError","Error","response","Requestable","apiBase","token","auth","username","password","AcceptHeader","Base64","path","url","newCacheBuster","raw","headers","requestOptions","date","method","data","cb","queryParams","shouldUseDataAsParams","methodHasNoBody","config","params","responseType","requestPromise","callbackErrorOrThrow","Object","options","results","thisGroup","message","nextUrl","getNextPage","parseInt","module","METHODS_WITH_NO_BODY","linksHeader","links","link","error","object","status","statusText","JSON"],"mappings":"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","sourcesContent":["/**\n * @file\n * @copyright  2016 Yahoo Inc.\n * @license    Licensed under {@link https://spdx.org/licenses/BSD-3-Clause-Clear.html BSD-3-Clause-Clear}.\n *             Github.js is freely distributable.\n */\n\nimport axios from 'axios';\nimport debug from 'debug';\nimport {Base64} from 'js-base64';\n\nconst log = debug('github:request');\n\n/**\n * The error structure returned when a network call fails\n */\nclass ResponseError extends Error {\n   /**\n    * Construct a new ResponseError\n    * @param {string} message - an message to return instead of the the default error message\n    * @param {string} path - the requested path\n    * @param {Object} response - the object returned by Axios\n    */\n   constructor(message, path, response) {\n      super(message);\n      this.path = path;\n      this.request = response.config;\n      this.response = (response || {}).response || response;\n      this.status = response.status;\n   }\n}\n\n/**\n * Requestable wraps the logic for making http requests to the API\n */\nclass Requestable {\n   /**\n    * Either a username and password or an oauth token for Github\n    * @typedef {Object} Requestable.auth\n    * @prop {string} [username] - the Github username\n    * @prop {string} [password] - the user's password\n    * @prop {token} [token] - an OAuth token\n    */\n   /**\n    * Initialize the http internals.\n    * @param {Requestable.auth} [auth] - the credentials to authenticate to Github. If auth is\n    *                                  not provided request will be made unauthenticated\n    * @param {string} [apiBase=https://api.github.com] - the base Github API URL\n    * @param {string} [AcceptHeader=v3] - the accept header for the requests\n    */\n   constructor(auth, apiBase, AcceptHeader) {\n      this.__apiBase = apiBase || 'https://api.github.com';\n      this.__auth = {\n         token: auth.token,\n         username: auth.username,\n         password: auth.password,\n      };\n      this.__AcceptHeader = AcceptHeader || 'v3';\n\n      if (auth.token) {\n         this.__authorizationHeader = 'token ' + auth.token;\n      } else if (auth.username && auth.password) {\n         this.__authorizationHeader = 'Basic ' + Base64.encode(auth.username + ':' + auth.password);\n      }\n   }\n\n   /**\n    * Compute the URL to use to make a request.\n    * @private\n    * @param {string} path - either a URL relative to the API base or an absolute URL\n    * @return {string} - the URL to use\n    */\n   __getURL(path) {\n      let url = path;\n\n      if (path.indexOf('//') === -1) {\n         url = this.__apiBase + path;\n      }\n\n      let newCacheBuster = 'timestamp=' + new Date().getTime();\n      return url.replace(/(timestamp=\\d+)/, newCacheBuster);\n   }\n\n   /**\n    * Compute the headers required for an API request.\n    * @private\n    * @param {boolean} raw - if the request should be treated as JSON or as a raw request\n    * @param {string} AcceptHeader - the accept header for the request\n    * @return {Object} - the headers to use in the request\n    */\n   __getRequestHeaders(raw, AcceptHeader) {\n      let headers = {\n         'Content-Type': 'application/json;charset=UTF-8',\n         'Accept': 'application/vnd.github.' + (AcceptHeader || this.__AcceptHeader),\n      };\n\n      if (raw) {\n         headers.Accept += '.raw';\n      }\n      headers.Accept += '+json';\n\n      if (this.__authorizationHeader) {\n         headers.Authorization = this.__authorizationHeader;\n      }\n\n      return headers;\n   }\n\n   /**\n    * Sets the default options for API requests\n    * @protected\n    * @param {Object} [requestOptions={}] - the current options for the request\n    * @return {Object} - the options to pass to the request\n    */\n   _getOptionsWithDefaults(requestOptions = {}) {\n      if (!(requestOptions.visibility || requestOptions.affiliation)) {\n         requestOptions.type = requestOptions.type || 'all';\n      }\n      requestOptions.sort = requestOptions.sort || 'updated';\n      requestOptions.per_page = requestOptions.per_page || '100'; // eslint-disable-line\n\n      return requestOptions;\n   }\n\n   /**\n    * if a `Date` is passed to this function it will be converted to an ISO string\n    * @param {*} date - the object to attempt to coerce into an ISO date string\n    * @return {string} - the ISO representation of `date` or whatever was passed in if it was not a date\n    */\n   _dateToISO(date) {\n      if (date && (date instanceof Date)) {\n         date = date.toISOString();\n      }\n\n      return date;\n   }\n\n   /**\n    * A function that receives the result of the API request.\n    * @callback Requestable.callback\n    * @param {Requestable.Error} error - the error returned by the API or `null`\n    * @param {(Object|true)} result - the data returned by the API or `true` if the API returns `204 No Content`\n    * @param {Object} request - the raw {@linkcode https://github.com/mzabriskie/axios#response-schema Response}\n    */\n   /**\n    * Make a request.\n    * @param {string} method - the method for the request (GET, PUT, POST, DELETE)\n    * @param {string} path - the path for the request\n    * @param {*} [data] - the data to send to the server. For HTTP methods that don't have a body the data\n    *                   will be sent as query parameters\n    * @param {Requestable.callback} [cb] - the callback for the request\n    * @param {boolean} [raw=false] - if the request should be sent as raw. If this is a falsy value then the\n    *                              request will be made as JSON\n    * @return {Promise} - the Promise for the http request\n    */\n   _request(method, path, data, cb, raw) {\n      const url = this.__getURL(path);\n\n      const AcceptHeader = (data || {}).AcceptHeader;\n      if (AcceptHeader) {\n         delete data.AcceptHeader;\n      }\n      const headers = this.__getRequestHeaders(raw, AcceptHeader);\n\n      let queryParams = {};\n\n      const shouldUseDataAsParams = data && (typeof data === 'object') && methodHasNoBody(method);\n      if (shouldUseDataAsParams) {\n         queryParams = data;\n         data = undefined;\n      }\n\n      const config = {\n         url: url,\n         method: method,\n         headers: headers,\n         params: queryParams,\n         data: data,\n         responseType: raw ? 'text' : 'json',\n      };\n\n      log(`${config.method} to ${config.url}`);\n      const requestPromise = axios(config).catch(callbackErrorOrThrow(cb, path));\n\n      if (cb) {\n         requestPromise.then((response) => {\n            if (response.data && Object.keys(response.data).length > 0) {\n               // When data has results\n               cb(null, response.data, response);\n            } else if (config.method !== 'GET' && Object.keys(response.data).length < 1) {\n               // True when successful submit a request and receive a empty object\n               cb(null, (response.status < 300), response);\n            } else {\n               cb(null, response.data, response);\n            }\n         });\n      }\n\n      return requestPromise;\n   }\n\n   /**\n    * Make a request to an endpoint the returns 204 when true and 404 when false\n    * @param {string} path - the path to request\n    * @param {Object} data - any query parameters for the request\n    * @param {Requestable.callback} cb - the callback that will receive `true` or `false`\n    * @param {method} [method=GET] - HTTP Method to use\n    * @return {Promise} - the promise for the http request\n    */\n   _request204or404(path, data, cb, method = 'GET') {\n      return this._request(method, path, data)\n         .then(function success(response) {\n            if (cb) {\n               cb(null, true, response);\n            }\n            return true;\n         }, function failure(response) {\n            if (response.response.status === 404) {\n               if (cb) {\n                  cb(null, false, response);\n               }\n               return false;\n            }\n\n            if (cb) {\n               cb(response);\n            }\n            throw response;\n         });\n   }\n\n   /**\n    * Make a request and fetch all the available data. Github will paginate responses so for queries\n    * that might span multiple pages this method is preferred to {@link Requestable#request}\n    * @param {string} path - the path to request\n    * @param {Object} options - the query parameters to include\n    * @param {Requestable.callback} [cb] - the function to receive the data. The returned data will always be an array.\n    * @param {Object[]} results - the partial results. This argument is intended for internal use only.\n    * @return {Promise} - a promise which will resolve when all pages have been fetched\n    * @deprecated This will be folded into {@link Requestable#_request} in the 2.0 release.\n    */\n   _requestAllPages(path, options, cb, results) {\n      results = results || [];\n\n      return this._request('GET', path, options)\n         .then((response) => {\n            let thisGroup;\n            if (response.data instanceof Array) {\n               thisGroup = response.data;\n            } else if (response.data.items instanceof Array) {\n               thisGroup = response.data.items;\n            } else {\n               let message = `cannot figure out how to append ${response.data} to the result set`;\n               throw new ResponseError(message, path, response);\n            }\n            results.push(...thisGroup);\n\n            const nextUrl = getNextPage(response.headers.link);\n            if(nextUrl) {\n               if (!options) {\n                  options = {};\n               }\n               options.page = parseInt(\n                 nextUrl.match(/(page=[0-9]*)/g)\n                   .shift()\n                   .split('=')\n                   .pop()\n               );\n               if (!(options && typeof options.page !== 'number')) {\n                  log(`getting next page: ${nextUrl}`);\n                  return this._requestAllPages(nextUrl, options, cb, results);\n               }\n            }\n\n            if (cb) {\n               cb(null, results, response);\n            }\n\n            response.data = results;\n            return response;\n         }).catch(callbackErrorOrThrow(cb, path));\n   }\n}\n\nmodule.exports = Requestable;\n\n// ////////////////////////// //\n//  Private helper functions  //\n// ////////////////////////// //\nconst METHODS_WITH_NO_BODY = ['GET', 'HEAD', 'DELETE'];\nfunction methodHasNoBody(method) {\n   return METHODS_WITH_NO_BODY.indexOf(method) !== -1;\n}\n\nfunction getNextPage(linksHeader = '') {\n   const links = linksHeader.split(/\\s*,\\s*/); // splits and strips the urls\n   return links.reduce(function(nextUrl, link) {\n      if (link.search(/rel=\"next\"/) !== -1) {\n         return (link.match(/<(.*)>/) || [])[1];\n      }\n\n      return nextUrl;\n   }, undefined);\n}\n\nfunction callbackErrorOrThrow(cb, path) {\n   return function handler(object) {\n      let error;\n      if (object.hasOwnProperty('config')) {\n         const {response: {status, statusText}, config: {method, url}} = object;\n         let message = (`${status} error making request ${method} ${url}: \"${statusText}\"`);\n         error = new ResponseError(message, path, object);\n         log(`${message} ${JSON.stringify(object.data)}`);\n      } else {\n         error = object;\n      }\n      if (cb) {\n         log('going to error callback');\n         cb(error);\n      } else {\n         log('throwing error');\n         throw error;\n      }\n   };\n}\n"]},"metadata":{},"sourceType":"script"}